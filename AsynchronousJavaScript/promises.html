// The Promise object is used to perform processing asynchronously. A promise represents value that may be available now, in the future, or even never.
/* 
There are three states for promises:
1. pending: initial state, the promise is neither kept nor broken;
2. fulfilled (held): the operation was successful;
3. Rejectedâ€”The operation failed.
A pending promise can be kept with a value 
*/

/* 
Constructor(Topic)
    Promise() - method
        Creates a new object. The constructor is primarily used to wrap functions that do not support promises.Promise
*/

// Promises will be complete in future.

// Most of the time we are going to consome promises but we can also create them.

// Here, we are taking an instance of a object(Promise).
const promiseOne = new Promise(function (resolve, reject) {
  // Do an async tasks
  // DB Calls, cryptography, network

  setTimeout(function () {
    console.log(`Async task is completed!`);
    resolve(); // to connect then()
  }, 1000);
});
// then is directly related to resolve or catch is directly related to reject
promiseOne.then(function () {
  console.log("Promise consumed!");
  //   this function receives an argument automatically.
});
/* 
Output=>
    Async task is completed!
    Promise consumed!
*/

/* 
Sometimes ago, if we want to perform the same task(means asynchronous tasks because we don't have promises at that time by default) then there is need to use some external libraries like Q and BlueBird(using these libraries we can use the, catch or fetch) after that community decides to include it as a core part of js. Now, there is no need to include then we can consume or create promises.
*/

// Another way to perform the above task

new Promise(function (resolve, reject) {
  setTimeout(function () {
    console.log("Async task 2");
    resolve();
  }, 1000);
}).then(function () {
  console.log("Async 2 resolved!");
});

/* 
Async task 2     
Async 2 resolved!
*/

const promiseThree = new Promise(function (resolve, reject) {
  setTimeout(function () {
    resolve({
      firstName: "Tarun",
      lastName: "Pal",
      age: 21,
    });
  }, 1000);
});

promiseThree.then(function (userInfo) {
  console.log(userInfo);
});

// { firstName: 'Tarun', lastName: 'Pal', age: 21 }

const promiseFour = new Promise(function (resolve, reject) {
  setTimeout(function () {
    let error = false; // true
    if (!error) {
      resolve({ firstName: "Tarun", lastName: "Pal", age: 21 });
    } else {
      reject("ERROR: Something went wrong!");
    }
  }, 1000);
});

// We can't consume value by assigning the whole consumption of promise to a variable.

// const myNamr = promiseFour.then((user) => {
//   console.log(user);
//   return user.userName;
// });

promiseFour
  .then((user) => {
    console.log(user);
    return user.firstName;
  })
  .then((myName) => {
    console.log(myName);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    console.log("The promise is either resolved or reject!");
  });
// Tarun
// The promise is either resolved or reject!

const promiseFive = new Promise(function (resolve, reject) {
  setTimeout(function () {
    let error = true;
    if (!error) {
      resolve({ username: "javascript", password: "123" });
    } else {
      reject("ERROR: JS went wrong!");
    }
  }, 1000);
});

async function consumePromiseFive() {
  // promise is an eventual completion object so we can not consume it like this: promiseFive()
  try {
    const response = await promiseFive;
    console.log(response);
  } catch (error) {
    console.log(error);
  }
}
consumePromiseFive();
// { username: 'javascript', password:
// '123' }

/* 
There is a problem with async and await method, it can not handle errors so there is need to expicitly mention by using try and catch. 
*/

// async function getAllUsers() {
//   try {
//     // it returns promise as a response.
//     const response = await fetch("https://jsonplaceholder.typicode.com/users");
//     const data = await response.json();
//     console.log(data);
//   } catch (error) {
//     console.log("E:", error);
//   }
// }
// getAllUsers();

// Above task by using then and catch

fetch("https://jsonplaceholder.typicode.com/users")
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.log(error);
  });


// callback hell or chaining(thenable)

// fetch() method was introduced in 2022(march)